[TOC]

# HTTP

## **基础普及**

+ 1.职业规划上的一点建议
   “开放分享”
   A:写一个属于自己的博客
    把自己的学习笔记以及到其他文章中去学习借鉴，然后把文章和学习感想发表出来...
   B:经常参加圈内的技术交流分享
   C:打造自己的自媒体
   ...

+ 2.搭建自己的博客
   A:可以基于第三方平台搭建
   B:基于gitHub发布页面(HEXO)
   C:自己创建博客项目，并且购买域名和服务器进行发布推广
    ->开发项目（项目代码在自己的本地）
    ->项目发布

  - 1）需要一台服务器 （万网->被阿里云收购了）
           虚拟云服务器 / 独立主机
           购买服务器成功后会有一个外网的IP地址（外网IP：任何用户通过这个IP地址都可以访问到你的服务器）

  - 2）需要一个域名
           .com/.cn...

  - 3）把域名进行DNS解析：把域名和服务器关联在一起（解析时候需要填写服务器的外网IP），以后访问域名就相当于访问服务器
           =>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库 （域名解析成功会在DNS系统中记录一条信息   “www.xxx.com  xxx.xxx.xx.xxx” 保证以后访问域名，可以直接找到外网IP，通过外网IP访问到服务器）
           

    ​		=>我们还要进行备案

  - 4）一台服务器可以发布很多项目，服务器买回来还不算结束，我们还需要在服务器上进行项目发布，此时需要一些发布WEB站的工具：IIS(C#.. ->WINDOWS)、APACHE TOMCAT(PHP/JAVA... ->LINUX)、NGINX(用的最多的)...
          ->指定当前域名访问服务器后，到底执行的是哪一个项目的源代码（让域名和服务器上的项目关联到一起）

+ 3.内网IP（局域网）
    在一个区域内，大家连接的是同一个网络（准确来说：连接同一个WIFI不一定是同一个网络，连接不同的WIFI也可能是相同的网络，一切都看路由交换机的配置），这就是局域网
    在同一个局域网下，成员可以互相访问（你的电脑连接了A网络，手机也连接了A网络，那么手机可以访问电脑上的一些信息了 =>这样可以做移动端开发时候的手机联调）
    HBuilder也提供了联调的功能（代码上加断点，手机访问，程序会走断点）

+ 4.怎么把自己本地的代码上传到远程服务器上
    ->服务器上是不允许安装除了开发需要的环境项以外的任何东西(保持服务器的干净)
    ->我们一般都基于FTP上传（有很多FTP上传的工具：FileZilla）



## 概念引入

【question】1. 打开一个浏览器，在地址栏输入一个网址，按下ENTER键，到看到整个页面，中间都经历了哪些事情?

**`【HTTP请求阶段：向服务器发送请求】`**
    1.浏览器首先向DNS域名解析服务器发送请求
    2.DNS反解析：根据浏览器请求地址中的域名，到DNS服务器中找到对应的服务器外网IP地址
    3.通过找到的外网IP，向对应的服务器发送请求（首先访问的是服务器的WEB站点管理工具:准确来说是我们先基于工具在服务器上创建很多服务，当有客户端访问的时候，服务器会匹配出具体是请求哪个服务）
    4.通过URL地址中携带的端口号，找到服务器上对应的服务，以及服务所管理的项目源文件
**`【HTTP响应阶段：服务器把客户端需要的内容准备好，并且返回给客户端】`**
    5.服务器端根据请求地址中的路径名称、问号传参或者哈希值，把客户端需要的内容进行准备和处理
    6.把准备的内容响应给客户端（如果请求的是HTML或者CSS等这样的资源文件，服务器返回的是资源文件中的源代码[不是文件本身]）
**`【浏览器渲染阶段】`**
    7.客户端浏览器接受到服务器返回的源代码，基于自己内部的渲染引擎（内核）开始进行页面的绘制和渲染
      ->首先计算DOM结构，生成DOM TREE
      ->自上而下运行代码，加载CSS等资源内容
      ->根据获取的CSS生成带样式的RENDER TREE
      ->开始渲染和绘制



### **【HTTP事务】**

> 一次**完整的** `请求+响应 ` 称之为 HTTP事务

### **【HTTP报文】**

> 在客户端向服务器发送请求，以及服务器把内容响应给客户端的时候，中间相互传递了很多内容(客户端把一些内容传递服务器，服务器把一些内容响应给客户端)，我们把传递的内容统称为“HTTP报文”



一个页面完全加载完成，需要向服务器发起很多次HTTP事务操作

>  一般来说：首先把HTML源代码拿回来，加载HTML的时候，遇到link/script/img[src]/iframe/video和audio[没有设置preload='none']...都会重新和服务器端建立HTTP事务交互
>  特殊情况：如果我们做了资源缓存处理(304)，而且即将加载的资源在之前已经加载过了，这样的操作和传统的HTTP事务有所不一样，他们是从服务器和浏览器的缓存中读取数据，比传统的读取快很多

---------------





## 1.完整URL组成



### 1.1 URI、URL、URN

>  URI=URL+URN
>
>   +  URI：统一资源标识符
>   +  URL：统一资源定位符
>   +  URN：统一资源名称
### 1.2 一个完整的url的详细说明

![1550763894204](C:\Users\82113\AppData\Roaming\Typora\typora-user-images\1550763894204.png)



#### 1.2.1【传输协议】

>  用来传输客户端和服务器端交互的信息的（类似于快递小哥）
>
> 一般有以下协议
>
> 1. HTTP：
>
>    超文本传输协议（除了传递普通的文本，还可以传递文件流或者进制编码等信息），是目前最常用的WEB传输协议
>
> 2. HTTPS：
>
>    基于SSL（Secure Sockets Layer 安全套接层）加密的HTTP传输协议，比HTTP更加的安全（涉及支付的网站一般都是基于HTTPS完成的）
>
> 3. FTP:
>
>    文件传输协议，一般用来实现资源文件在服务器上的上传下载



#### 1.2.2【域名】 Domain Name

  + 一级域名（顶级域名）  www.qq.com
   + 二级域名   sports.qq.com
   + 三级域名   kbs.sports.qq.com
   + .com 供商用的国际域名
   + .cn 供商用的中文域名
   + .net 用于网络供应服务商（系统类的经常使用NET域名）
   + .org 用于官方组织
   + .edu 用于教育院校
   + .gov 用于政府机构

#### 1.2.3 [端口号]
> 用来区分同一台服务器上不同服务的标识（基于WEB服务管理器创建服务的时候可以指定），不同服务之间一般是不能使用相同的端口号的

 + HTTP =>默认端口号80
 + HTTPS =>默认端口号443
 + FTP =>默认端口号21   

> 如果当前网站服务，采用的是协议对应的默认端口管理，那么当用户输入网址的时候可以不指定端口号，浏览器会默认把用户把默认的端口传递给服务器
>     一台服务器上的端口号范围：0~65535之间
>     WEBSTORM预览页面：WS把自己的电脑当做服务器，在服务器上创建一个服务，端口号是63342，自己电脑上的浏览器预览自己电脑上的服务，属于本机服务请求，用localhost(127.0.0.1)本地域名即可
>     http://localhost:63342/web-2019/js/javascript/test.html
>     服务器上安装一款应用都可能会作为一个服务，占用一个端口号

#### 1.2.4  [请求路径名称]

+ path

   + pathname


        例如：/stu/index.html 一般都是请求当前服务对应的项目目录中，STU文件夹中的INDEX.HTML页面。但是也有特情况，就是当前的URL是被“伪URL重写”的，我们看到的URL请求其实不是真实的请求（例如 https://item.jd.com/4679424.html 这个URL就是被重写的，它的真实URL地址很可能是 https://item.jd.com/detail.jsp?id=4679424，其实就是跳转到详情页，通过问号传递不同的产品编号，展示不同的产品详情信息，但是.jsp这种服务器渲染的动态页面不能被搜索引擎收录，不利于页面的SEO，所以我们会把动态页面静态化，这也就用到了URL重写技术）
         例如：/stu/info 这种没有任何后缀信息，一般都不是用来请求资源文件的，而是用于AJAX数据请求的接口地址（如果后缀是.json类的，也是同理），但是有一种除外 /stu/info/ 这种的很可能不是接口地址，而是没有指定请求的资源名称，服务器会请求默认的资源文件，一般都是index.html/default.html...
         DHTML：动态页面，泛指当前页面中的内容不是写死的而是动态绑定的，例如.jsp/.php/.aspx...这些页面中的数据都是基于AJAX或者是后台编程语言处理，由服务器端渲染，最后把渲染后的结果返回给客户端呈现的
       [问号传参及哈希值]
         ?xxx=xxx&...#xxx
         在HTTP事务中，问号传参是客户端把信息传递给服务器的一种方式(也有可能是跳转到某一个页面，把参数值传递给页面用来标识的)
         哈希值一般都跟客户端服务器交互没啥关系，主要用于页面中的锚点定位和HASH路由切换



 ####1.2.5 [问号传参及哈希值]
`?xxx=xxx&...#xxx`

 在HTTP事务中，问号传参是客户端把信息传递给服务器的一种方式(也有可能是跳转到某一个页面，把参数值传递给页面用来标识的)

哈希值一般都跟客户端服务器交互没啥关系，主要用于页面中的锚点定位和HASH路由切换



## 2.HTTP报文

起始行：请求起始行、响应起始行
首部（头）：请求头、响应头、通用头
主体：请求主体、响应主体



###2.1 General 通用头

```
Request URL: https://www.baidu.com/  请求地址
Request Method: GET  请求方式:GET/POST/DELETE/PUT/HEAD/OPTION...
Status Code: 304 Not Modified   响应的HTTP状态码
Remote Address: 125.39.174.137:80  主机地址(服务器外网IP地址)
Referrer Policy: no-referrer-when-downgrade
```

### 2.2 Request Headers 请求头 [客户端设置，服务器接收]

```
GET / HTTP/1.1  =>起始行(描述当前请求的一些基本信息：用的是1.1版本传输协议进行内容传输的)
Host: www.baidu.com
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: ... =>cookie信息一般都是放到头文件中实现和服务器端的数据通信的
If-Modified-Since: Sun, 06 May 2018 10:02:42 GMT
```

### 2.3 Response Headers 响应头 [服务器端设置，客户端获取]

```
HTTP/1.1 304 Not Modified  =>响应起始行（HTTP状态码）
Date: Tue, 22 May 2018 09:18:56 GMT  =>服务器响应内容时候的“服务器端时间”（客户端获取这个时间的时候已经和真实的时间产生误差了，因为服务器返回内容到客户端接收到，也是需要时间的），并且这个时间是格林尼治时间（比北京时间慢8小时，北京时间是GMT+0800）
Connection: keep-alive
ETag: "700a6f-17f43-56b86a77513d3"
Vary: Accept-Encoding,User-Agent
Server: yunjiasu-nginx  //=>管理WEB服务的工具
CF-RAY: 41ee32c192db66b8-TSN
```

### 2.4 Response [响应主体]

```
  服务器返回的是啥就是啥
```

### 2.5 Request Payload / Form Data  [请求主体]

```
  客户端传递给服务器的内容
```

### 2.6  HTTP报文的作用和使用

>  以后涉及到交互功能（前端<=>后台）出现问题，都按照如下方式查找问题原因
>    A:打开控制台，在NET-WORK中找到当前交互的请求地址，点击进去看详情
>    B:如果是传递给服务器的参数或者方式错误 [前端问题]
>    C:如果服务器返回的信息有错误或者和API接口文档规定的内容不一样 [后台问题]
>    D:如果返回数据是对的，但是展示有问题 [前端问题]

>  确定是自己前端的问题后，基于断点(或者代码中的debugger)或者控制台输出等方式，开始逐步调试即可

### 2.7 客户端和服务器端信息交互的方式

 > [客户端传递给服务器]
 >      A:问号传参
 >       请求的URL地址末尾通过问号传参方式，把一些信息传递给服务器
 >       /stu/info?id=12&lx=man
 > B:设置请求头
 >       客户端把需要传递给服务器的内容设置到请求头信息中（自定义请求头）,服务器可以通过接收请求头信息把内容得到
 >  C:设置请求主体
 >       xhr.send([AJAX SEND中传递的内容，就是客户端设置的请求主体内容，服务器端可以接收到这些信息的]);

 > [服务器返回给客户端]
 >   A:设置响应头信息
 >    例如把服务时间通过响应头返回给客户端，客户端通过获取响应头信息得到这个时间（响应头返回的速度是优先于响应主体的）
 > B:设置响应主体
 >    主要的返回信息都在响应主体中

##3. `前端开发性能优化方案`

减少HTTP请求次数和请求大小
代码优化
  ->有利于SEO
  ->有利于扩展维护
  ->有利于减少性能消耗
  [JS代码优化的108条建议]  [雅虎CSS优化的36条建议]
  ...
DNS及HTTP通信方式的优化

#### 3.1减少HTTP请求次数和请求大小

> 1. 尽量合并CSS和JS文件（把需要引入的CSS合并为一个，JS也是合并为一个），原理是在减少HTTP请求次数，尽可能的把合并后的代码进行压缩，减小HTTP请求资源的大小
>      A:webpack这种自动化构建工具，可以帮我们实现代码的合并和压缩（工程化开发）
>      B:在移动开发(或者追求高性能的PC端开发\[例如百度首页])，如果CSS或者JS不是需要很多，我们可以选择把css和js编程内嵌式（也就是代码直接写在HTML中）
>
>    
>
> 2. 利用浏览器和服务器端的缓存技术(304缓存)，把一些不经常更新的静态资源文件做缓存处理（例如：JS、CSS、静态图片等都可以做缓存）
>       原理是为了减少HTTP请求大小，让获取速度更快
>
>    
>
> 3. 页面中的数据获取采用异步编程和延迟分批加载
>      使用异步获取数据，是为了降低HTTP通道的堵塞，不会因为数据没有请求回来耽误下面信息的渲染，提高页面的打开速度（我们可以这样处理：需要动态绑定数据的区域先隐藏，等数据返回并且绑定完成后在让其显示）
>      延迟分批加载类似于图片懒加载，是为了减少第一次页面加载时候的HTTP请求次数
>
>    
>
> 4. 利用H5中提供的localstorage本地存储或者是manifest离线缓存，做一些信息的本地存储，下一次加载页面的时候直接从本地获取，减少HTTP请求次数
>
> 

#### 3.2 代码优化

> 1. 在JS中尽量减少闭包的使用（原因：闭包会产生不释放的栈内存）
>      A:循环给元素做事件绑定的时候，尽可能的把后期需要的信息（例如索引）存储到元素的自定义属性上，而不是创建闭包存储
>      B:可以在最外层形成一个闭包，把一些后续需要的公共信息进行存储，而不是每一个方法都创建闭包(例如单例模式)
>      C:尽可能的手动释放不被占用的内存
>      ...
>
>    
>
> 2. 尽可能使用事件委托(事件代理)来处理事件绑定的操作，减少DOM的频繁操作，其中包括给每一个DOM元素做事件绑定
>
>    
>
> 3. 尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片（因为字体图标等是矢量图(基于代码编写出来的)，放大不会变形，而且渲染速度快，相对比位图要小一些）
>
>    
>
> 4. 减少对DOM的操作（主要是减少DOM的重绘和回流(重排)）
>      A:关于重排的分离读写
>      B:使用文档碎片或者字符串拼接做数据绑定(DOM的动态创建)
>
>    
>
> 5. 在JS中避免“嵌套循环”（这种会额外增加很多循环次数）和“死循环”（一旦遇到死循环浏览器就卡壳了）
>
>    
>
> 6. 采用图片的“懒加载”（延迟加载）
>      目的是为了减少页面“第一次加载”过程中HTTP的请求次数，让页面打开速度变快
>      步骤：开始加载页面的时候，所有的真实图片都不去发送HTTP请求加载，而是给一张占位的背景图，当页面加载完，并且图片在可视区域内我们再去做图片加载
>
>    
>
> 7. 尽量减少CSS表达式的使用(expression)
>
>      ```
>      #myDiv {
>        position: absolute;
>        width: 100px;
>        height: 100px;
>        left: expression(document.body.offsetWidth - 110 + "px");
>        top: expression(document.body.offsetHeight - 110 + "px");
>        background: red;
>      }
>      ```
>
> 8. CSS选择器解析规则是从右向左解析
>    ```
>     .container .link a{
>        先找到所有的A，再筛选是在.link样式类中的，再次筛选是在.container样式类中的... 先找到的是所有的A，操作起来是消耗性能的，我们在使用CSS选择器的时候尽可能减少对标签选择器的使用
>     }
>    ```
>
> 9. CSS雪碧图技术(css sprite / css 图片精灵)
>      把所有相对较小资源图片汇总到一张大图上，后期我们只需要把大图加载下来，用背景定位的方式展示对应的小图即可
>      ```
>      .bg{
>        background:url('xxx.png');
>      }
>      .box1{
>         background-position:xx xx;
>      }
>      .box2{
>         background-position:xx xx;
>      }
>      <div class='bg box1'></div>
>      ```
>
> 10. 页面中出现音视频标签，我们不让页面加载的时候就去加载这些资源（要不然页面加载速度会变慢）（方案：只需要设置 preload='none' 即可），等待页面加载完成，音视频播放的时候我们在去加载音视频资源
>
>     
>
> 11. 在客户端和服务器端进行信息交互的时候，对于多项数据我们尽可能基于JSON格式来进行传送（JSON格式的数据处理方便，资源偏小） ==>相对于XML格式的传输才会有这个优势
>
>     
>
> 12. 尽可能实现JS的封装（低耦合高内聚），减少页面中的冗余代码（减少HTTP请求资源的大小）
>
>     
>
> 13. CSS中设置定位后，最好使用Z-INDEX改变盒子的层级，让所有的盒子不在相同的平面上，这样后续处理的时候，性能有那么一丢丢的提高
>
>     
>
> 14. 在基于AJAX的GET请求进行数据交互的时候，根据需求可以让其产生缓存（这个缓存不是304缓存），这样下一次从相同地址获取的数据是上一次缓存的数据（但是很少用，项目中一般刻意清除这个缓存的时候偏多）
>
>     
>
> 15. 尽量减少对于filter滤镜属性的使用(这个属性消耗性能较大一些)
>
>     
>
> 16. 在CSS导入的时候尽量减少使用@import导入式，因为@import是同步操作，只有把这个对应的CSS导入，才会向下加载，而link是异步操作
>
>     
>
> 17. 使用window.requestAnimationFrame（JS中的帧动画）代替传统的定时器动画
>
>     
>
> 18. 减少递归的使用，避免死递归，避免由于递归导致的栈内存嵌套（建议使用尾递归）
>
>     
>
> 19. 避免使用iframe（不仅不好管控样式，而且相当于在A页面中加载了其它页面，消耗较大）
>
>     
>
> 20. 基于SCRIPT调取JS的时候，可已使用 defer或者async 来异步加载
>
>     

#### 3.3 DNS及HTTP通信方式的优化

> 1. 减少对于COOKIE的使用（最主要的是减少本地COOKIE存储内容的大小），因为客户端操作COOKIE的时候，这些信息总是在客户端和服务器端传来传去
> 2. 配置ETag(有点类似于304缓存)

#### 3.4 其他技巧

> 1. 我们一般都把CSS放到BODY上，把JS放到BODY下面（原因：让其先加载CSS在加载JS，先加载CSS是为了保证页面渲染的过程中，元素是带着样式渲染的，而JS一般都是用来操作DOM元素的，需要等到元素加载完再操作）
> 2. 能用CSS搞定的绝对不用JS，能用原生JS搞定的绝对不用插件，绝对不使用FLASH（除了音视频的低版本浏览器播放）
>      =>CSS处理动画等功能的性能优于JS，而且CSS中的transform变形还开起了硬件加速
> 3.  JS中尽量减少对EVAL的使用，因为JS合并压缩的时候，可能出现由于符号不完善，导致的代码执行优先级错乱问题，EVAL处理起来消耗的性能也是偏大一点的
> 4. 使用keep-alive实现客户端和服务器端的长连接
> 5. 尽量使用设计模式来管理我们的代码（单例、构造、Promise、发布订阅），方便后期的升级和维护
> 6.  开启服务器端的gzip压缩（这个压缩可以有效减少请求资源文件的大小），其实客户端的图片等资源也是可以进行压缩的（但是对于24位的位图，压缩后可能会变模糊）
> 7. 页面中不要出现无效的链接（利于SEO优化），还有其它技巧：提高关键字曝光率、img需要加alt、设置meta标签、标签语义化...
> 8. 避免使用with语句（非常耗性能）

### 4 .http的请求方式



> HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式

 

#### 4.1、OPTIONS

返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性

#### 4.2、HEAD

向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。

#### 4.3、GET

向特定的资源发出请求。它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。

#### 4.4、POST

向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form

#### 4.5、PUT

向指定资源位置上传其最新内容

#### 4.6、DELETE

请求服务器删除Request-URL所标识的资源

#### 4.7、TRACE

回显服务器收到的请求，主要用于测试或诊断

#### 4.8、CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

注意：

1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。

2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。



## 5. HTTP 状态码（status）

根据状态码能够清楚的反映出当前交互的结果及原因
- 200  OK 成功(只能证明服务器成功返回信息了，但是信息不一定是你业务需要的)

- 301 Moved Permanently 永久转移（永久重定向）
    =>域名更改，访问原始域名重定向到新的域名

- 302 Move temporarily 临时转移（临时重定向 =>307）
    =>网站现在是基于HTTPS协议运作的，如果访问的是HTTP协议，会基于307重定向到HTTPS协议上
    =>302一般用作服务器负载均衡：当一台服务器达到最大并发数的时候，会把后续访问的用户临时转移到其它的服务器机组上处理
    =>偶尔真实项目中会把所有的图片放到单独的服务器上“图片处理服务器”，这样减少主服务器的压力，当用户向主服务器访问图片的时候，主服务器都把它转移到图片服务器上处理

- 304 Not Modified 设置缓存
    =>对于不经常更新的资源文件，例如：CSS/JS/HTML/IMG等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端了，下次再获取的时候，是从缓存中获取；如果资源更新了，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取；基于CTRL+F5强制刷新页面，304做的缓存就没有用了。
- 400 Bad Request 请求参数错误
- 401 Unauthorized 无权限访问
- 404 Not Found  找不到资源(地址不存在)
- 413 Request Entity Too Large 和服务器交互的内容资源超过服务器最大限制

- 500 Internal Server Error 未知的服务器错误
- 503 Service Unavailable 服务器超负荷

